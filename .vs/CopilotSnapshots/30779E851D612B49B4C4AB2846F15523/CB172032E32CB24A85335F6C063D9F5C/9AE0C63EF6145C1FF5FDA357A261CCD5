using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Calcularoa_C_S2_Tr1.Modelos;

namespace Calcularoa_C_S2_Tr1.Controladores
{
 public class Controlador_con
 {
     // Parsea la expresión y devuelve un objeto Guardar_numero_signo
     public Guardar_numero_signo ParseExpression(string expr)
     {
         if (expr == null)
         expr = string.Empty;

         expr = expr.Trim();

         var result = new Guardar_numero_signo();

         var numbers = new List<decimal>();
         var operators = new List<char>();

         string num = "";
         foreach (char c in expr)
         {
             if (char.IsDigit(c) || c == '.')
             {
                num += c;
             }
            else
            {
                if (num != "")
            {
                numbers.Add(decimal.Parse(num, CultureInfo.InvariantCulture));
                num = "";
            }

                // Sólo guardar operadores válidos
                if (c == '+' || c == '-' || c == '*' || c == '/')
                operators.Add(c);
                // Ignorar otros caracteres (espacios, '=' u otros)
            }
         }
         if (num != "")
            numbers.Add(decimal.Parse(num, CultureInfo.InvariantCulture));

            result.Numbers = numbers;
            result.Operators = operators;

     return result;
     }

     // Calcula el resultado respetando precedencia: primero * y /, luego + y -
     public decimal CalculateResult(Guardar_numero_signo data)
     {
         if (data == null)
         throw new ArgumentNullException(nameof(data));

         // Trabajar sobre copias para no mutar el modelo original
         var nums = new List<decimal>(data.Numbers);
         var ops = new List<char>(data.Operators);

         var calc = new Calculadora();

         // Primero multiplicaciones y divisiones
         for (int i =0; i < ops.Count; i++)
         {
             if (ops[i] == '*' || ops[i] == '/')
             {
                 decimal a = nums[i];
                 decimal b = nums[i +1];
                 decimal res;

                 if (ops[i] == '*')
                 res = calc.Multiply(a, b);
                 else
                 res = calc.Divide(a, b); // puede lanzar DivideByZeroException

                 nums[i] = res;
                 nums.RemoveAt(i +1);
                 ops.RemoveAt(i);
                 i--; // retroceder índice para reevaluar en la nueva posición
             }
         }

         // Luego sumas y restas
         for (int i =0; i < ops.Count; i++)
         {
             if (ops[i] == '+' || ops[i] == '-')
             {
                 decimal a = nums[i];
                 decimal b = nums[i +1];
                 decimal res;

                 if (ops[i] == '+')
                 res = calc.Add(a, b);
                 else
                 res = calc.Subtract(a, b);

                 nums[i] = res;
                 nums.RemoveAt(i +1);
                 ops.RemoveAt(i);
                 i--;
             }
         }

         return nums.Count >0 ? nums[0] :0m;
     }

     // Conveniencia: parsea y calcula en una sola llamada
     public decimal ComputeExpression(string expr)
     {
         var parsed = ParseExpression(expr);
         return CalculateResult(parsed);
     }
 }
}
