using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Calcularoa_C_S2_Tr1.Modelos;

namespace Calcularoa_C_S2_Tr1.Controladores
{
    public class Controlador_calculadora
    {
        private readonly Calculadora calculadora_obj = new Calculadora();

        // Calcula el resultado respetando su orden de operaciones
        public decimal Calcular_resultado(Guardar_numero_signo data)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));

        // Trabajar sobre copias para no mutar el modelo original
        var numeros = new List<decimal>(data.Numeros);
        var operadores = new List<char>(data.Operadores);

        // Manejar operador de porcentaje '%' como operador unario que afecta al número anterior
        for (int idx =0; idx < operadores.Count; idx++)
        {
            if (operadores[idx] == '%')
            {
                // Convertir numero anterior a su porcentaje (ej:50% ->0.5)
                // Aquí asumimos que '%' se aplica al número inmediatamente anterior
                decimal baseValue = numeros[idx];
                decimal porcentaje = numeros[idx] /100m;

                // Reemplazar el número anterior por su porcentaje
                numeros[idx] = porcentaje;
                // Remover el operador '%' porque ya fue aplicado
                operadores.RemoveAt(idx);
                idx--;
            }
        }

        // Primero multiplicacion y division
        for (int idx =0; idx < operadores.Count; idx++)
        {
            if (operadores[idx] == '*' || operadores[idx] == '/')
            {
                decimal valor_a = numeros[idx];
                decimal valor_b = numeros[idx +1];
                decimal resultado;

             if (operadores[idx] == '*')
                resultado = calculadora_obj.Multiplicacio(valor_a, valor_b);
            else
                resultado = calculadora_obj.Divicion(valor_a, valor_b);

            numeros[idx] = resultado;
            numeros.RemoveAt(idx +1);
            operadores.RemoveAt(idx);
                idx--; // retroceder índice para reevaluar en la nueva posición
            }
        }

         // Suma y resta
        for (int idx =0; idx < operadores.Count; idx++)
        {
           if (operadores[idx] == '+' || operadores[idx] == '-')
           {
                decimal valor_a = numeros[idx];
                decimal valor_b = numeros[idx +1];
                decimal resultado;

           if (operadores[idx] == '+')
                resultado = calculadora_obj.Suma(valor_a, valor_b);
           else
                resultado = calculadora_obj.Resta(valor_a, valor_b);

                numeros[idx] = resultado;
                numeros.RemoveAt(idx +1);
                operadores.RemoveAt(idx);
                idx--;
           }
        }

        return numeros.Count >0 ? numeros[0] :0m;
        }
     }
}
